

3-55:
  简要分析题目中的代码，我们知道x是32位的，而y是64位的，我们将x按符号扩展到64位，这一步即为汇编中的3，4行的作用。
  实际上，x在符号扩展后，与y相乘的64位结果是一样的。
  X = X(high)*2^32 + X(low)
  Y = Y(high)*2^32 + Y(low)
  X*Y = {X(high) * Y(high)}*2^64 +{X(low)*Y(high) +X(high)*Y(low)}*2^32 + {X(low)*Y(low)}
        \__________ 1 _________/  \_________________ 2 _______________/    \____ 3 _____/
        
   我们要取它的低64位结果，故（1）直接省略;
   64位结果中，低32位的结果可以直接使用（3）计算出来;
   高32位的结果由两部分构成：（2）的低32位结果+（3）的高32位结果;
   要得到（3）的高32位结果，我们需要使用mul的单操作数形式，在edx中保存乘积的高32位。需要注意的是这里使用mul无符号简洁运算，是由于64位的低32位可以盾作无符号数。因此，如果使用imul，虽然低32位结果是正确的，但是高32位的结果却是错误的。
  
3-57：

3-60：
 A) 先给出二维的位置公式：D[i][j] = D + L(C*i +j)
  三维数组表示形式：A[R][S][T]
  由代码中可推导出:A[i][j][k] = 63i+9j+k 
  此处是个三给数组，可以将其当作一个磨坊来想，先把它切成一片片的，可以得到3片(编号：0,1,2)，而每片中有9个元素，可将其看作一个二维数组(3X3),此时假如在第0片里定位一个元素位置，就跟普通的二维数组一样了。但当想找的元素不在第0片中时，我们需要先跨过第0片，才能到下一片中去找，因此跨过一片就需要S*T=3*3，在哪一片中就是(S*T)*i，然后再在片里找，跟二维数组一样T*j+k 
  因此 三维数组的位置公式为：A[i][j][k] = A + L{(S*T)i + T*j + k }
 B) 由上可得T=9 S=7 R=2772/63=44
 
3-63:
  解析：
  矩阵就是二维数组D[R][C]，元素的位置公式： D[i][j] =  D + 4(C*i + j)
  到8行的时候，此时 %ebx = 4(2n-1)，到11行的时候：%ecx = A+4j，这就是A矩阵的第一行中的第j列元素的位置，
  之后进入.L4 循环，%edx作为i变量不断的自增1, 每增一次后就需要跳到矩阵的下一行去寻找第j列的元素位置%ecx=A+(2n-1+j)*4，判断条件：cmpl %esi，%edx (即：i(%edx)<3n(%esi),%esi的值在4行中得到),然后继续循环加值。
  #define E1(n) (3n)
  #define E2(n) (2n-1)
  
3.64： 
  A) 5行：movl 8(%ebp),%eax  ;取出的是result
     6行：movl 16(%ebp),%ebx ;取出的是s1.v
     7行：movl 12(%ebp),%edx ;取出的是s1.p
  B) 
  C)
  D)
  